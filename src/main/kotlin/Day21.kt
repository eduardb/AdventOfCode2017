@file:Suppress("PackageDirectoryMismatch")

package day21

// on (#) or off (.)

fun main(args: Array<String>) {
    /*val input = 2 to """../.# => ##./#../...
.#./..#/### => #..#/..../..../#..#"""*/
    val input = 18 to """../.. => ###/.#./.##
#./.. => .../###/#.#
##/.. => #.#/..#/..#
.#/#. => ##./.##/..#
##/#. => ###/.../###
##/## => ###/##./.#.
.../.../... => .#../..##/...#/....
#../.../... => .#../..##/.##./####
.#./.../... => .#../###./.#../#..#
##./.../... => #.##/#..#/...#/.#..
#.#/.../... => ##.#/.#.#/#.#./..##
###/.../... => #..#/#.##/..../#.##
.#./#../... => .#.#/.#../..../.#.#
##./#../... => ###./..../.##./###.
..#/#../... => .#../###./####/.#..
#.#/#../... => ..##/.#../#.#./##.#
.##/#../... => #..#/##../.###/#...
###/#../... => #.##/##../.#.#/####
.../.#./... => ####/.###/..#./###.
#../.#./... => ###./..../#.../#...
.#./.#./... => .#../###./.#.#/....
##./.#./... => #.##/#..#/.#.#/##..
#.#/.#./... => #.../..../##../....
###/.#./... => ..../...#/##../####
.#./##./... => ..../.###/.#.#/#...
##./##./... => ..##/.##./###./#.##
..#/##./... => ...#/#.#./#.#./#..#
#.#/##./... => ..##/###./#.##/..#.
.##/##./... => .###/..../##../#.##
###/##./... => .#../...#/..##/##..
.../#.#/... => ...#/#.##/#.../####
#../#.#/... => .##./.#../###./.###
.#./#.#/... => ##.#/.#.#/#.../.##.
##./#.#/... => ####/#..#/..#./....
#.#/#.#/... => #.##/.##./####/.#..
###/#.#/... => ..##/..#./#..#/.#..
.../###/... => #..#/#.../.##./.##.
#../###/... => ##../###./#.##/####
.#./###/... => .#../..##/#..#/...#
##./###/... => ..#./#..#/.###/..#.
#.#/###/... => #..#/#.#./#.#./#.##
###/###/... => #.../.##./..../.##.
..#/.../#.. => .###/.##./.##./#.##
#.#/.../#.. => #.../..#./.###/...#
.##/.../#.. => #..#/..../.##./.#.#
###/.../#.. => .##./##.#/.#.#/##..
.##/#../#.. => ...#/#.##/.#../.#..
###/#../#.. => ##.#/#.#./#.../##..
..#/.#./#.. => .#../#.../#.../####
#.#/.#./#.. => .##./.##./#.##/.#.#
.##/.#./#.. => ##../.#.#/#.../.#..
###/.#./#.. => ..#./.#../..#./.###
.##/##./#.. => #.../#..#/..##/###.
###/##./#.. => ..../#..#/.#../####
#../..#/#.. => ..#./#.#./####/#...
.#./..#/#.. => .##./.###/#.../#.#.
##./..#/#.. => ##../.#.#/...#/#.##
#.#/..#/#.. => ####/###./##.#/...#
.##/..#/#.. => ##.#/###./#..#/###.
###/..#/#.. => .###/#..#/...#/.#.#
#../#.#/#.. => ##../##../#.../##.#
.#./#.#/#.. => #.../.###/...#/..#.
##./#.#/#.. => .#../..../#..#/..##
..#/#.#/#.. => ##../##.#/..#./#..#
#.#/#.#/#.. => .#../###./#.##/#.##
.##/#.#/#.. => ..../..#./#..#/####
###/#.#/#.. => ####/.#.#/...#/###.
#../.##/#.. => .#.#/#.##/##.#/.###
.#./.##/#.. => ##.#/#.#./.#.#/.##.
##./.##/#.. => .##./#.#./..../.#..
#.#/.##/#.. => ###./.#../#.../....
.##/.##/#.. => #.##/##../#.##/...#
###/.##/#.. => .##./..../...#/##..
#../###/#.. => #..#/#..#/#..#/####
.#./###/#.. => .#.#/#.#./.#.#/####
##./###/#.. => ##../#.#./#..#/....
..#/###/#.. => .##./##../..../###.
#.#/###/#.. => ..##/#.../#.../#.#.
.##/###/#.. => ..##/##.#/#.##/#.##
###/###/#.. => .#.#/..##/###./.#..
.#./#.#/.#. => ..../.#../.###/.#..
##./#.#/.#. => ...#/#.../.#.#/...#
#.#/#.#/.#. => ..../..##/..../.#..
###/#.#/.#. => #.#./#.##/##../###.
.#./###/.#. => #.##/..#./.#../###.
##./###/.#. => .#../..##/...#/#.#.
#.#/###/.#. => #.../...#/###./#...
###/###/.#. => ..##/##.#/..#./#.#.
#.#/..#/##. => .#.#/#.#./####/..#.
###/..#/##. => #..#/##.#/..../#...
.##/#.#/##. => #..#/...#/#.##/.#..
###/#.#/##. => .#.#/###./#.../#.##
#.#/.##/##. => .#../#.#./.#../..#.
###/.##/##. => ..#./##../##../.###
.##/###/##. => .###/#.##/##../.##.
###/###/##. => ..##/#.../.#.#/..##
#.#/.../#.# => .#../.#../##.#/.##.
###/.../#.# => .#.#/...#/.#../#.#.
###/#../#.# => ...#/#..#/..#./.###
#.#/.#./#.# => ##../##.#/####/...#
###/.#./#.# => .#.#/...#/..#./#..#
###/##./#.# => .###/##.#/.#../#.##
#.#/#.#/#.# => #.../#.../.#.#/...#
###/#.#/#.# => .#../#.#./##.#/..#.
#.#/###/#.# => .###/#..#/####/####
###/###/#.# => ####/#..#/.##./#...
###/#.#/### => #.#./..##/#.../#.#.
###/###/### => .###/.##./#.#./...#"""

    println(Day21a.solveFor(input.first, input.second.split('\n')))
}

val startImage = ImageParser.parse(".#./..#/###")

object ImageParser {

    fun parse(rawImage: String) = Image(
            rawImage.split('/')
                    .map {
                        it.map { it == '#' }
                    }
    )
}

object PatternParser {

    fun parse(rawPattern: String) = with(rawPattern.split(" => ")) {
        Pattern(
                ImageParser.parse(get(0)),
                ImageParser.parse(get(1))
        )
    }
}

data class Image(private val pixels: List<List<Boolean>>) {

    companion object {
        fun from(subimages: List<List<Image>>): Image = if (subimages.size == 1) {
            subimages[0][0]
        } else {
            val subimageSize = subimages[0][0].size
            val size = subimages.size * subimageSize
            Image(
                    Array(size) { row ->
                        Array(size) { column ->
                            subimages[row / subimageSize][column / subimageSize][row % subimageSize, column % subimageSize]
                        }.toList()
                    }.toList()
            )
        }
    }

    val size: Int
        get() = pixels.size

    val onPixels: Int
        get() = pixels.sumBy { row -> row.count { it } }

    operator fun get(x: Int, y: Int): Boolean = pixels[x][y]

    fun flip(): Image {
        return Image(pixels.map { it.reversed() })
    }

    fun rotate90() = Image(
            Array(size) { row ->
                Array(size) { column ->
                    this[size - column - 1, row]
                }.toList()
            }.toList()
    )

    fun rotate180(): Image = rotate90().rotate90()

    fun rotate270(): Image = rotate180().rotate90()

    fun divide(): List<List<Image>> = if (size % 2 == 0) {
        (0 until size / 2).map { row ->
            (0 until size / 2).map { column ->
                Image(
                        pixels.subList(row * 2, (row + 1) * 2)
                                .map { it.subList(column * 2, (column + 1) * 2) }
                )
            }
        }
    } else {
        (0 until size / 3).map { row ->
            (0 until size / 3).map { column ->
                Image(
                        pixels.subList(row * 3, (row + 1) * 3)
                                .map { it.subList(column * 3, (column + 1) * 3) }
                )
            }
        }
    }
}

class Pattern(private val from: Image, val to: Image) {

    val forSize: Int
        get() = from.size

    fun matches(image: Image): Boolean {
        if (forSize != image.size) {
            return false
        }
        return image == from || image == from.flip()
                || image == from.rotate90() || image == from.rotate180() || image == from.rotate270()
                || image == from.flip().rotate90() || image == from.flip().rotate180() || image == from.flip().rotate270()
    }
}

object Day21a {
    fun solveFor(iterations: Int, rawPatterns: List<String>): Int {

        val patterns = rawPatterns.map { PatternParser.parse(it) }

        var image = startImage

        repeat(iterations) {
            val subimages = image.divide()
            val filteredPatterns = patterns.filter {
                it.forSize == subimages[0][0].size
            }
            image = subimages.map {
                it.map { subimage ->
                    filteredPatterns.find {
                        it.matches(subimage)
                    }!!.to
                }
            }.toImage()
        }

        return image.onPixels
    }

}

private fun List<List<Image>>.toImage(): Image = Image.from(this)

